#include <SFML/Graphics.hpp>
#include <iostream>
#include <cmath>
#include<cctype>;
#include<fstream>

using namespace std;
void Repeatcmdbreaker(char command[], char commands[][1000], int numbers[], int& commandCount, char colorCommands[][1000], int& colorCommandCount) {
    // Skip to the first '['
    int i = 0;
    while (command[i] != '[') i++;
    i++; // Skip the '['

    // Check if ']' is in the command
    bool foundClosingBracket = false;
    for (int j = i; command[j] != '\0'; j++) {
        if (command[j] == ']') {
            foundClosingBracket = true;
        }
    }

    // If ']' is not found, return without doing anything
    if (!foundClosingBracket) return;

    int commandIndex = 0, numberIndex = 0;
    char number[100] = {};
    bool readingNumber = false;
    bool readingColor = false;

    while (command[i] != ']') {
        if (command[i] >= '0' && command[i] <= '9') { // If the character is a number
            number[numberIndex++] = command[i];
            readingNumber = true;
        }
        else if ((command[i] >= 'a' && command[i] <= 'z') || (command[i] >= 'A' && command[i] <= 'Z')) { // If the character is a letter
            if (readingNumber) {
                numbers[commandCount] = atoi(number); // Convert the current number to an integer
                memset(number, 0, sizeof(number)); // Clear the number array
                numberIndex = 0;
                readingNumber = false;
                commandCount++; // Increment commandCount 
            }
            commands[commandCount][commandIndex++] = command[i];
            if (strncmp(commands[commandCount], "colour", 6) == 0) {
                readingColor = true;
            }
        }
        else if (command[i] == ' ') { // If the character is a space
            if (commandIndex > 0 && !readingColor) {
                commands[commandCount][commandIndex] = '\0'; // Null-terminate the current command
                commandIndex = 0;
            }
        }
        i++;
    }

    // null-terminate the last command 
    if (commandIndex > 0) {
        commands[commandCount][commandIndex] = '\0';
    }
    if (readingNumber) {
        numbers[commandCount] = atoi(number);
    }
    if (readingColor) {
        strcpy_s(colorCommands[colorCommandCount++], commands[commandCount]);
        readingColor = false;
    }
    if (!readingNumber) {
        commandCount++;
    }
}


int getRepeatCount(char command[]) {
    if (strncmp(command, "repeat", 6) == 0) {
        int i = 6; // Start from the character after "repeat"
        while (command[i] == ' ') i++; // Skip any spaces
        int repeatCount = 0;
        while (command[i] >= '0' && command[i] <= '9') {
            repeatCount = repeatCount * 10 + (command[i] - '0');
            i++;
        }
        return repeatCount;
    }
    return -1; // Return -1 if the command is not a repeat command
}
sf::CircleShape myCircle(float rad, sf::RenderWindow& window, float xaxis, float yaxis)
{
    sf::CircleShape circle(rad);
    circle.setPosition(xaxis - rad, yaxis - rad);
    circle.setFillColor(sf::Color::Transparent);
    circle.setOutlineColor(sf::Color::White);
    circle.setOutlineThickness(1);
    return circle;
}


bool colorcheck(char commandentered[][100], const char color[], int k)
{
    // Check if the command starts with the provided color string
    return strncmp(commandentered[k], color, strlen(color)) == 0;
}

void colorname(char commandentered[][100], char name[], int k)
{
    int i = 0;

    // Skip characters until ' '
    while (commandentered[k][i] && !isspace(commandentered[k][i]))
    {
        i++;
    }

    // Skip spaces
    while (commandentered[k][i] && isspace(commandentered[k][i]))
    {
        i++;
    }

    int j = 0;
    while (commandentered[k][i] && isalpha(commandentered[k][i]))
    {
        name[j++] = toupper(commandentered[k][i++]);  // Convert to uppercase
    }

    // Null-terminate the name
    name[j] = '\0';
}

bool check(char commandentered[][100], char x[], int k) {
    int stop = 0;
    for (int i = 0;i < 6 && stop == 0;i++) {
        if (commandentered[k][i] != x[i]) {
            stop = 1;
        }

    }
    if (stop == 0) {
        return true;
    }
    else {
        return false;
    }

}




void cmdBreaker(char input[], int& numberExtracted, char charExtracted[])
{
    int alphaIndex = 0;

    for (int j = 0; input[j] != '\0'; ++j)
    {
        if (std::isalpha(input[j]))
        {
            charExtracted[alphaIndex++] = input[j];
        }
        else if (std::isdigit(input[j]))
        {

            numberExtracted = numberExtracted * 10 + (input[j] - '0');
        }
        else if (std::isspace(input[j])) {
            charExtracted[alphaIndex++] = '\0';
        }
    }
    charExtracted[alphaIndex] = '\0';
}




sf::RectangleShape drawForward(int& distance, sf::RenderWindow& window, float& x, float& y, float width, float& angle, float theta, float& sumAngle)
{

    sf::RectangleShape rectangle;
    float rad_angle = sumAngle * 3.14159f / 180.0f;
    y = y - distance * cos(rad_angle);
    x = x + distance * sin(rad_angle);
    rectangle.setPosition(x - width / 2, y);
    rectangle.setSize(sf::Vector2f(width, distance));
    rectangle.rotate(sumAngle);

    return rectangle;


}

sf::RectangleShape drawBackward(int& distance, sf::RenderWindow& window, float& x, float& y, int width, float& angle, float theta, float& sumAngle)
{
    sf::RectangleShape rectangle;

    rectangle.rotate(sumAngle);
    float rad_angle = sumAngle * 3.14159f / 180.0f;
    rectangle.setPosition(x - width / 2, y);
    rectangle.setSize(sf::Vector2f(width, distance));
    y = y + distance * cos(rad_angle);
    x = x - distance * sin(rad_angle);
    return rectangle;
}




void clearScreen(int& lineIndex, int& historyCmdIndex, float& xaxis, float& yaxis, float& angle)
{
    lineIndex = 0;
    historyCmdIndex = 0;
    xaxis = 700;
    yaxis = 450;
    angle = 0.0;

}


void penUp(sf::ConvexShape& cursor, float distance, float& xaxis, float& yaxis, float& sumAngle)
{

    float rad_angle = sumAngle * 3.14159f / 180.0f;
    yaxis = yaxis - distance * cos(rad_angle);
    xaxis = xaxis + distance * sin(rad_angle);
    cursor.setPosition(xaxis, yaxis);


}

void penDown(sf::ConvexShape& cursor, float distance, float& xaxis, float& yaxis, float& sumAngle)
{

    float rad_angle = sumAngle * 3.14159f / 180.0f;
    yaxis = yaxis + distance * cos(rad_angle);
    xaxis = xaxis - distance * sin(rad_angle);
    cursor.setPosition(xaxis, yaxis);


}

sf::Color getColorFromString(const char colorName[]) {
    if (strcmp(colorName, "blue") == 0) {
        return sf::Color::Blue;
    }
    else if (strcmp(colorName, "green") == 0) {
        return sf::Color::Green;
    }
    else if (strcmp(colorName, "red") == 0) {
        return sf::Color::Red;
    }
    else if (strcmp(colorName, "white") == 0) {
        return sf::Color::White;
    }
    else if (strcmp(colorName, "yellow") == 0) {
        return sf::Color::Yellow;
    }
    else if (strcmp(colorName, "cyan") == 0) {
        return sf::Color::Cyan;
    }
    else if (strcmp(colorName, "magenta") == 0) {
        return sf::Color::Magenta;
    }
    else if (strcmp(colorName, "black") == 0) {
        return sf::Color::Black;
    }
    else if (strcmp(colorName, "gray") == 0) {
        return sf::Color(128, 128, 128);
    }
    else if (strcmp(colorName, "brown") == 0) {
        return sf::Color(165, 42, 42);  // Brown color
    }
    else {
        return sf::Color::White;  // Default to white if the color name is not recognized
    }
}


int main()
{
    const int maxsizeofcmd = 100;
    char commandentered[100][maxsizeofcmd] = { " " };
    int historyCmdIndex = 0;
    int maincommandIndex = 0;
    int numberExtracted;
    int lineIndex = 0;
    float width = 1.0;
    float angle = 0.0, theta = 0.0;
    float sumAngle = 0.0;
    bool isPenUp = false;
    int pu = 0;
    int temp = 10000, temp2 = 10000;
    int flag = 0;
    char x[7] = { "repeat" };
    char y[6] = { "color" };
    bool knowncommand = false;
    char name[20];
    int  e = 1000;
    ofstream fout("PF.txt");
    ifstream fin("PF.txt");

    float xaxis = 700, yaxis = 450;
    sf::RenderWindow window(sf::VideoMode(1400, 700), "SFML works!");
    sf::VertexArray line(sf::Lines, 2);
    line[0].position = sf::Vector2f(0, 600);
    line[1].position = sf::Vector2f(1050, 600);

    sf::RectangleShape rectangle;
    rectangle.setSize(sf::Vector2f(350, 1200));
    rectangle.setPosition(sf::Vector2f(1050, 200));
    rectangle.setFillColor(sf::Color::Transparent);

    rectangle.setOutlineColor(sf::Color::White);
    rectangle.setOutlineThickness(1);

    sf::RectangleShape lines[100];
    sf::CircleShape circles[100];


    sf::Font open_Arial;
    open_Arial.loadFromFile("C:\\Users\\DELL\\source\\repos\\Project5\\Project5\\Arial.ttf");



    sf::Text commandText;
    commandText.setFont(open_Arial);
    commandText.setCharacterSize(22);
    commandText.setFillColor(sf::Color::White);
    commandText.setPosition(180, 603); // Adjust the Y position as needed

    sf::ConvexShape cursor(3);

    while (window.isOpen())
    {

        cursor.setPoint(0, sf::Vector2f(0, -10));
        cursor.setPoint(1, sf::Vector2f(10, 10));
        cursor.setPoint(2, sf::Vector2f(-10, 10));
        cursor.setFillColor(sf::Color::Red);
        cursor.setPosition(xaxis, yaxis);
        sf::Event event;
        window.clear();












        sf::Text my_text;
        my_text.setFont(open_Arial);
        my_text.setString("Command :");
        my_text.setPosition(sf::Vector2f(20, 600));
        my_text.setOutlineThickness(-6);
        my_text.setCharacterSize(25);

        sf::Text me_text;
        me_text.setFont(open_Arial);
        me_text.setString("Command History:");
        me_text.setPosition(sf::Vector2f(1080, 200));
        me_text.setCharacterSize(25);

        sf::Text unknown;
        unknown.setFont(open_Arial);
        unknown.setString("Unknown Command");
        unknown.setCharacterSize(25);


        sf::Text Commandtext;
        Commandtext.setFont(open_Arial);
        Commandtext.setCharacterSize(22);
        Commandtext.setFillColor(sf::Color::White);
        Commandtext.setPosition(0, 600);

        sf::Text Historytext;
        Historytext.setFont(open_Arial);
        Historytext.setCharacterSize(22);
        Historytext.setFillColor(sf::Color::White);
        Historytext.setPosition(1110, 200);

        while (window.pollEvent(event)) {

            if (event.type == sf::Event::Closed)
                window.close();
            if (flag == 0) {
                if (event.type == sf::Event::TextEntered)
                {


                    if (event.text.unicode < 128 && event.text.unicode != 13)
                    {

                        commandentered[historyCmdIndex][maincommandIndex++] = static_cast<char>(event.text.unicode);
                        commandText.setString(std::string(commandentered[historyCmdIndex]));

                        commandentered[historyCmdIndex][maincommandIndex] = '\0';


                    }


                    else if (event.text.unicode == 13)
                    {

                        knowncommand = false;


                        int textIndex = 0;
                        numberExtracted = 0;
                        char charExtracted[100];
                        cmdBreaker(commandentered[historyCmdIndex], numberExtracted, charExtracted);
                        historyCmdIndex++;

                        if (strcmp(charExtracted, "fd") == 0)
                        {
                            knowncommand = true;
                            lines[lineIndex] = sf::RectangleShape(drawForward(numberExtracted, window, xaxis, yaxis, width, angle, theta, sumAngle));
                            lineIndex++;

                        }
                        if (strcmp(charExtracted, "bk") == 0)
                        {
                            knowncommand = true;
                            lines[lineIndex] = sf::RectangleShape(drawBackward(numberExtracted, window, xaxis, yaxis, width, angle, theta, sumAngle));
                            lineIndex++;

                        }
                        if (strcmp(charExtracted, "lt") == 0)
                        {
                            knowncommand = true;
                            theta = numberExtracted;
                            sumAngle = sumAngle - theta;
                            if ((numberExtracted % 30) == 0 || (numberExtracted % 45) == 0) {
                                cursor.setRotation(sumAngle);
                            }
                            else {
                                knowncommand = false;
                                sumAngle = sumAngle + theta;
                            }

                        }
                        if (strcmp(charExtracted, "rt") == 0)
                        {

                            knowncommand = true;
                            theta = numberExtracted;
                            sumAngle = sumAngle + theta;
                            if ((numberExtracted % 30) == 0 || (numberExtracted % 45) == 0) {
                                cursor.setRotation(sumAngle);
                            }
                            else {
                                knowncommand = false;
                                sumAngle = sumAngle - theta;
                            }

                        }
                        if (strcmp(charExtracted, "cs") == 0)
                        {
                            knowncommand = true;
                            clearScreen(lineIndex, historyCmdIndex, xaxis, yaxis, angle);
                            cursor.rotate(360 - sumAngle);
                            sumAngle = 0;
                            historyCmdIndex = historyCmdIndex + 2;

                        }

                        if (strcmp(charExtracted, "pu") == 0)
                        {
                            knowncommand = true;
                            pu = 1;
                            temp = lineIndex;
                        }
                        if (strcmp(charExtracted, "pd") == 0)
                        {
                            knowncommand = true;
                            temp2 = lineIndex;
                            pu = 0;
                        }
                        if (colorcheck(commandentered, y, (historyCmdIndex - 1)) == true)
                        {
                            knowncommand = true;
                            colorname(commandentered, name, (historyCmdIndex - 1));


                            for (int i = 0; name[i]; i++)
                            {
                                name[i] = tolower(name[i]);
                            }
                        }
                        if (strcmp(charExtracted, "circle") == 0)
                        {
                            knowncommand = true;
                            float rad = numberExtracted;
                            circles[lineIndex] = myCircle(rad, window, xaxis, yaxis);
                            lineIndex++;
                        }
                        if (strcmp(charExtracted, "save") == 0) {
                            knowncommand = true;
                            int z = 0;
                            while (z < historyCmdIndex) {
                                fout << commandentered[z];
                                z++;
                                fout << endl;
                            }

                        }
                        if (strcmp(charExtracted, "load") == 0) {
                            knowncommand = true;
                            flag = 1;
                        }
                        if (strcmp(charExtracted, "width") == 0) {
                            knowncommand = true;
                            width = numberExtracted;
                        }
                        if (check(commandentered, x, (historyCmdIndex - 1)) == true) {
                            knowncommand = true;
                            int repeatCount = getRepeatCount(commandentered[historyCmdIndex - 1]);
                            if (repeatCount != -1) {
                                //std::cout << "Repeat count: " << repeatCount << std::endl;
                                char commands[100][1000] = {};
                                int numbers[1000] = {};
                                char colorCommands[100][1000];
                                int colorCommandCount = 0;
                                int commandCount = 0;
                                Repeatcmdbreaker(commandentered[historyCmdIndex - 1], commands, numbers, commandCount, colorCommands, colorCommandCount);
                                for (int i = 0; i < commandCount; i++) {
                                    cout << "Command: " << commands[i] << ", Number: " << numbers[i] << std::endl;

                                }
                                for (int i = 0; i < colorCommandCount; i++) {
                                    cout << "Color command: " << colorCommands[i] << std::endl;
                                }
                                for (int repeat = 0; repeat < repeatCount; repeat++) {
                                    for (int i = 0; i < commandCount + 1; i++) {
                                        if (strcmp(commands[i], "fd") == 0 || strcmp(commands[i], "forward") == 0) {
                                            int length = numbers[i];
                                            lines[lineIndex] = sf::RectangleShape(drawForward(length, window, xaxis, yaxis, width, angle, theta, sumAngle));
                                            lineIndex++;


                                        }
                                        if (strcmp(commands[i], "bk") == 0 || strcmp(commands[i], "backward") == 0) {
                                            int length = numbers[i];
                                            lines[lineIndex] = sf::RectangleShape(drawBackward(length, window, xaxis, yaxis, width, angle, theta, sumAngle));
                                            lineIndex++;
                                        }
                                        if (strcmp(commands[i], "circle") == 0) {
                                            int radius = numbers[i];
                                            circles[lineIndex] = myCircle(radius, window, xaxis, yaxis);
                                            lineIndex++;

                                        }
                                        if (strcmp(commands[i], "rt") == 0) {

                                            theta = numbers[i];

                                            sumAngle = sumAngle + theta;
                                            if ((numbers[i] % 30) == 0 || (numbers[i] % 45) == 0) {
                                                cursor.setRotation(sumAngle);
                                            }
                                            else {

                                                sumAngle = sumAngle - numbers[i];
                                            }
                                        }
                                        if (strcmp(commands[i], "lt") == 0) {

                                            theta = numbers[i];


                                            sumAngle = sumAngle - theta;
                                            if ((numbers[i] % 30) == 0 || (numbers[i] % 45) == 0) {
                                                cursor.setRotation(sumAngle);
                                            }
                                            else {
                                                knowncommand = false;
                                                sumAngle = sumAngle + numbers[i];
                                            }
                                        }
                                        if (strcmp(commands[i], "pu") == 0) {
                                            pu = 1;
                                            temp = lineIndex;
                                        }
                                        if (strcmp(commands[i], "pd") == 0) {

                                            temp2 = lineIndex;
                                            pu = 0;
                                        }
                                        if (strcmp(commands[i], "cs") == 0) {
                                            clearScreen(lineIndex, historyCmdIndex, xaxis, yaxis, angle);
                                            cursor.rotate(360 - sumAngle);
                                            sumAngle = 0;
                                            historyCmdIndex = historyCmdIndex + 2;
                                        }

                                        if (strncmp(colorCommands[i], "colour", 6) == 0)
                                        {

                                            colorname(commandentered, name, (historyCmdIndex - 1));
                                        }
                                        if (strcmp(charExtracted, "width") == 0) {
                                            knowncommand = true;
                                            width = numberExtracted;
                                        }


                                    }


                                }



                            }



                        }


                        maincommandIndex = 0;
                    }


                }

            }
            else if (flag == 1) {
                
                knowncommand = false;
                int c = historyCmdIndex;
                while (c < 100 && fin.getline(commandentered[c], maxsizeofcmd)) {
                    c++;
                }
                numberExtracted = 0;
                char charExtracted[100];
                cmdBreaker(commandentered[historyCmdIndex], numberExtracted, charExtracted);
                historyCmdIndex++;
                width = 1.0;
                
                if (strcmp(charExtracted, "fd") == 0)
                {
                    knowncommand = true;

                    lines[lineIndex] = sf::RectangleShape(drawForward(numberExtracted, window, xaxis, yaxis, width, angle, theta, sumAngle));
                    lineIndex++;

                }
                if (strcmp(charExtracted, "bk") == 0)
                {
                    knowncommand = true;
                    lines[lineIndex] = sf::RectangleShape(drawBackward(numberExtracted, window, xaxis, yaxis, width, angle, theta, sumAngle));
                    lineIndex++;

                }
                if (strcmp(charExtracted, "lt") == 0)
                {

                    knowncommand = true;
                    theta = numberExtracted;
                    sumAngle = sumAngle - theta;
                    if ((numberExtracted % 30) == 0 || (numberExtracted % 45) == 0) {
                        cursor.setRotation(sumAngle);
                    }
                    else {

                        sumAngle = sumAngle + theta;
                    }

                }
                if (strcmp(charExtracted, "rt") == 0)
                {

                    knowncommand = true;
                    theta = numberExtracted;
                    sumAngle = sumAngle + theta;
                    if ((numberExtracted % 30) == 0 || (numberExtracted % 45) == 0) {
                        cursor.setRotation(sumAngle);
                    }
                    else {

                        sumAngle = sumAngle - theta;
                    }

                }
                if (strcmp(charExtracted, "cs") == 0)
                {
                    knowncommand = true;
                    clearScreen(lineIndex, historyCmdIndex, xaxis, yaxis, angle);
                    cursor.rotate(360 - sumAngle);
                    sumAngle = 0;
                    historyCmdIndex = historyCmdIndex + 2;

                }

                if (strcmp(charExtracted, "pu") == 0)
                {
                    knowncommand = true;
                    penUp(cursor, 50.0f, xaxis, yaxis, sumAngle);
                }
                if (strcmp(charExtracted, "pd") == 0)
                {
                    knowncommand = true;
                    penDown(cursor, 50.0f, xaxis, yaxis, sumAngle);
                }
                if (colorcheck(commandentered, y, (historyCmdIndex - 1) == true))

                {
                    knowncommand = true;

                    colorname(commandentered, name, (historyCmdIndex - 1));


                    for (int i = 0; name[i]; i++)
                    {
                        name[i] = tolower(name[i]);
                    }
                }
                if (strcmp(charExtracted, "circle") == 0)
                {
                    knowncommand = true;
                    float rad = numberExtracted;
                    circles[lineIndex] = myCircle(rad, window, xaxis, yaxis);
                    lineIndex++;
                }
                if (strcmp(charExtracted, "save") == 0) {
                    knowncommand = true;
                    int z = 0;
                    while (z < historyCmdIndex) {
                        fout << commandentered[z];
                        z++;
                        fout << endl;
                    }

                }
                if (strcmp(charExtracted, "width") == 0) {
                    knowncommand = true;
                    width = numberExtracted;
                }
                if (check(commandentered, x, (historyCmdIndex - 1)) == true) {
                    knowncommand = true;
                    int repeatCount = getRepeatCount(commandentered[historyCmdIndex - 1]);
                    if (repeatCount != -1) {
                        //std::cout << "Repeat count: " << repeatCount << std::endl;
                        char commands[100][1000] = {};
                        int numbers[1000] = {};
                        char colorCommands[100][1000];
                        int colorCommandCount = 0;
                        int commandCount = 0;
                        Repeatcmdbreaker(commandentered[historyCmdIndex - 1], commands, numbers, commandCount, colorCommands, colorCommandCount);
                        for (int i = 0; i < commandCount; i++) {
                            cout << "Command: " << commands[i] << ", Number: " << numbers[i] << std::endl;

                        }
                        for (int i = 0; i < colorCommandCount; i++) {
                            cout << "Color command: " << colorCommands[i] << std::endl;
                        }
                        for (int repeat = 0; repeat < repeatCount; repeat++) {
                            for (int i = 0; i < commandCount + 1; i++) {
                                if (strcmp(commands[i], "fd") == 0 || strcmp(commands[i], "forward") == 0) {
                                    int length = numbers[i];
                                    lines[lineIndex] = sf::RectangleShape(drawForward(length, window, xaxis, yaxis, width, angle, theta, sumAngle));
                                    lineIndex++;


                                }
                                if (strcmp(commands[i], "bk") == 0 || strcmp(commands[i], "backward") == 0) {
                                    int length = numbers[i];
                                    lines[lineIndex] = sf::RectangleShape(drawBackward(length, window, xaxis, yaxis, width, angle, theta, sumAngle));
                                    lineIndex++;
                                }
                                if (strcmp(commands[i], "circle") == 0) {
                                    int radius = numbers[i];
                                    circles[lineIndex] = myCircle(radius, window, xaxis, yaxis);
                                    lineIndex++;

                                }
                                if (strcmp(commands[i], "rt") == 0) {

                                    theta = numbers[i];

                                    sumAngle = sumAngle + theta;
                                    if ((numbers[i] % 30) == 0 || (numbers[i] % 45) == 0) {
                                        cursor.setRotation(sumAngle);
                                    }
                                    else {

                                        sumAngle = sumAngle - numbers[i];
                                    }
                                }
                                if (strcmp(commands[i], "lt") == 0) {

                                    theta = numbers[i];


                                    sumAngle = sumAngle - theta;
                                    if ((numbers[i] % 30) == 0 || (numbers[i] % 45) == 0) {
                                        cursor.setRotation(sumAngle);
                                    }
                                    else {
                                        knowncommand = false;
                                        sumAngle = sumAngle + numbers[i];
                                    }
                                }
                                if (strcmp(commands[i], "pu") == 0) {
                                    pu = 1;
                                    temp = lineIndex;
                                }
                                if (strcmp(commands[i], "pd") == 0) {

                                    temp2 = lineIndex;
                                    pu = 0;
                                }
                                if (strcmp(commands[i], "cs") == 0) {
                                    clearScreen(lineIndex, historyCmdIndex, xaxis, yaxis, angle);
                                    cursor.rotate(360 - sumAngle);
                                    sumAngle = 0;
                                    historyCmdIndex = historyCmdIndex + 2;
                                }

                                if (strncmp(colorCommands[i], "colour", 6) == 0)
                                {

                                    colorname(commandentered, name, (historyCmdIndex - 1));
                                }
                                if (strcmp(charExtracted, "width") == 0) {
                                    knowncommand = true;
                                    width = numberExtracted;
                                }


                            }


                        }



                    }



                }

                maincommandIndex = 0;
                flag = 0;
            }
        }



        //for delete
        for (int k = 0; k < lineIndex; k++) {

            if (pu == 1) {
                if (k < temp) {
                    lines[k].setFillColor(getColorFromString(name));
                    lines[k].setSize(sf::Vector2f(width, lines[k].getSize().y));
                    window.draw(lines[k]);
                }
                else if (k >= temp) {
                    lines[k].setFillColor(sf::Color::Black);
                    window.draw(lines[k]);
                }
            }
            else if (pu == 0) {
                if (k >= temp && k < temp2) {
                    lines[k].setFillColor(sf::Color::Black);
                    window.draw(lines[k]);
                }
                else {
                    lines[k].setFillColor(getColorFromString(name));
                    lines[k].setSize(sf::Vector2f(width, lines[k].getSize().y));
                    window.draw(lines[k]);
                }
            }
        }

        for (int k = 0; k < lineIndex; k++)
        {

            if (pu == 1) {
                if (k < temp) {
                    circles[k].setOutlineColor(getColorFromString(name));
                    circles[k].setOutlineThickness(width);
                    window.draw(circles[k]);
                }
                else if (k >= temp) {
                    circles[k].setOutlineColor(sf::Color::Black);
                    window.draw(circles[k]);
                }
            }
            else if (pu == 0) {
                if (k >= temp && k < temp2) {
                    circles[k].setOutlineColor(sf::Color::Black);
                    window.draw(circles[k]);
                }
                else {
                    circles[k].setOutlineColor(getColorFromString(name));
                    circles[k].setOutlineThickness(width);
                    window.draw(circles[k]);
                }
            
            }
            

        }
        window.draw(line);
        window.draw(rectangle);
        window.draw(cursor);
        window.draw(my_text);
        window.draw(me_text);
        window.draw(commandText);

        float Positioncmdhis = 230.0f;
        if (knowncommand == false) {
            e = historyCmdIndex - 1;
            

        }
        
        for (int i = 0, f = 0; i < historyCmdIndex; i++)
        {

            if (knowncommand == false) {

                strcpy_s(commandentered[historyCmdIndex-1], "unknown command");

            }
            
                const auto& history = commandentered[i];
            
            
            
            Historytext.setString(history);
            Historytext.setString(std::to_string(i + 1) + ") " + history);
            Historytext.setPosition(1110, Positioncmdhis);
            window.draw(Historytext);
            Positioncmdhis += 30.0f;
        }
        
        window.display();
    }

    return 0;
}

